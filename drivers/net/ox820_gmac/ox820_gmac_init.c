/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include "ox820_gmac.h"

static struct ox820_sysctrl_registers_t* const regs_sysctrl = (struct ox820_sysctrl_registers_t*) SYS_CONTROL_BASE;

/*=============================================================================*/
void ox820_gmac_initialize_regs(struct ox820_gmac_t* gmac)
{
	unsigned int idx;
	unsigned long val;

	/* Reset the GMAC core */
	switch(gmac->gmac_unit) {
		case 1:
			val = MSK_OX820_SYSCTRL_RSTEN_ETHB;
			break;
		case 0:
			val = MSK_OX820_SYSCTRL_RSTEN_ETHA;
			break;

		default:
			val = 0;
			break;
	}
	regs_sysctrl->rsten_set_ctrl = val;
	wmb();
	regs_sysctrl->rsten_clr_ctrl = val;
	wmb();

	gmac->gmac_regs->mac_config = 0;
	gmac->gmac_regs->interrupt_mask = ~0;	/* Interrupt mask is showing disabled lines */

	/* initialize GMAC clocks */
	val = ((1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_GTX) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_SIMPLE_MUX) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_AUTO_TX_SOURCE) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_TX_OUT) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_TXN_OUT) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_TX_IN) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_RX_OUT) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_RXN_OUT) |
		(1UL << BIT_OX820_SYSCTRL_GMAC_CTRL_CKEN_RX_IN));
	switch(gmac->gmac_unit) {
		case 1:
			regs_sysctrl->gmacb_ctrl |= val;
			break;
		case 0:
			regs_sysctrl->gmaca_ctrl |= val;
			break;
	}

	/* RGMII tuning */
	switch(gmac->gmac_unit) {
		case 0:
			regs_sysctrl->gmaca_delay = (0x4 << BIT_OX820_SYSCTRL_GMAC_DELAY_TX_VARDELAY) |
							(0x2 << BIT_OX820_SYSCTRL_GMAC_DELAY_TXN_VARDELAY) |
							(0xa << BIT_OX820_SYSCTRL_GMAC_DELAY_RX_VARDELAY) |
							(0x8 << BIT_OX820_SYSCTRL_GMAC_DELAY_RXN_VARDELAY);
			break;
		case 1:
			regs_sysctrl->gmacb_delay = (0x4 << BIT_OX820_SYSCTRL_GMAC_DELAY_TX_VARDELAY) |
							(0x2 << BIT_OX820_SYSCTRL_GMAC_DELAY_TXN_VARDELAY) |
							(0xa << BIT_OX820_SYSCTRL_GMAC_DELAY_RX_VARDELAY) |
							(0x8 << BIT_OX820_SYSCTRL_GMAC_DELAY_RXN_VARDELAY);
			break;
	}

	gmac->gmac_regs->vlan_tag = 0;
	gmac->gmac_regs->pmt_control_status = 0;
	for(idx = 0; idx < 16; ++idx) {
		if(0 != idx) {
			gmac->gmac_regs->mac_addr[idx].high = 0;
		}
		gmac->gmac_regs->mac_addr2[idx].high = 0;
	}

	gmac->gmac_regs->mac_frame_filter = 0;
	gmac->gmac_regs->hash_table_high = 0;
	gmac->gmac_regs->hash_table_low = 0;

	/* Initialise flow control register contents
	 */
	// Enable Rx flow control
	val = MSK_OX820_GMAC_FLOW_CONTROL_RFE;

	/*if (priv->mii.using_pause) {*/
		// Enable Tx flow control
	//	reg_contents |= MSK_OX820_GMAC_FLOW_CONTROL_TFE;
	/*}*/

	// Set the duration of the pause frames generated by the transmitter when
	// the Rx fifo fill threshold is exceeded
	val |= ((0x100UL << BIT_OX820_GMAC_FLOW_CONTROL_PT) |	// Pause for 256 slots
					 (0x1UL << BIT_OX820_GMAC_FLOW_CONTROL_PLT));

	// Write flow control setup to the GMAC
	gmac->gmac_regs->flow_control = val;

	/* Initialise operation mode register contents
	 */
	// Initialise the GMAC DMA operation mode register. Set Tx/Rx FIFO thresholds
	// to make best use of our limited SDRAM bandwidth when operating in gigabit
	val = VAL_OX820_GMAC_DMA_OPMODE_TTC_128 |	// Tx threshold
            (1UL << BIT_OX820_GMAC_DMA_OPMODE_FUF) |    // Forward Undersized good Frames
            VAL_OX820_GMAC_DMA_OPMODE_RTC_128 |		// Rx threshold 128 bytes
            (1UL << BIT_OX820_GMAC_DMA_OPMODE_OSF);	// Operate on 2nd frame

	// Enable hardware flow control
                    val |= MSK_OX820_GMAC_DMA_OPMODE_EFC;

	switch (gmac->gmac_unit) {
		/* 810 has 32KB Rx FIFO, 820 port 0 has 16KB while 820 port 1 has 8KB
		 */
		case 0:
			printk(KERN_INFO "%s: Setting Rx flow control thresholds for LAN port\n", gmac->netdev->name);

			// Set threshold for enabling hardware flow control at (full-4KB) to
			// give space for upto two in-flight std MTU packets to arrive after
			// pause frame has been sent.
			val |= (0UL << BIT_OX820_GMAC_DMA_OPMODE_RFA2) |
				(3UL << BIT_OX820_GMAC_DMA_OPMODE_RFA);

			// Set threshold for disabling hardware flow control (-7KB)
			val |= (1UL << BIT_OX820_GMAC_DMA_OPMODE_RFD2) |
				(2UL << BIT_OX820_GMAC_DMA_OPMODE_RFD);
			break;
		case 1:
			printk(KERN_INFO "%s: Setting Rx flow control thresholds for WAN port\n", gmac->netdev->name);

			// Allow for a bit more than one in-flight 1500 byte MTU packet to
			// arrive after flow control is enabled (full-2KB)
			val |= (0UL << BIT_OX820_GMAC_DMA_OPMODE_RFA2) |
				(1UL << BIT_OX820_GMAC_DMA_OPMODE_RFA);

			// Disable flow control when there's nearly enough space for two
			// 1500 byte MTU packets before flow control would be enabled
			// (full-5KB)
			val |= (1UL << BIT_OX820_GMAC_DMA_OPMODE_RFD2) |
				(0UL << BIT_OX820_GMAC_DMA_OPMODE_RFD);
			break;
		default:
			BUG();
	}

	// Don't flush Rx frames from FIFO just because there's no descriptor available
	val |= MSK_OX820_GMAC_DMA_OPMODE_DFF;

	// Write settings to operation mode register
	gmac->gmac_regs->dma_opmode = val;

    	// GMAC requires store&forward in order to compute Tx checksums
    	gmac->gmac_regs->dma_opmode |= MSK_OX820_GMAC_DMA_OPMODE_TSF;

	gmac->gmac_regs->dma_intenable = MSK_OX820_GMAC_DMA_INTENABLE_RIE | MSK_OX820_GMAC_DMA_INTENABLE_TIE;
	gmac->gmac_regs->mmc_rx_mask = ~0;
	gmac->gmac_regs->mmc_tx_mask = ~0;
	wmb();
	/* Acknowledge remaining interrupts for now */
	gmac->gmac_regs->mii_status;
	gmac->gmac_regs->dma_status = gmac->gmac_regs->dma_status;

	wmb();
	gmac->gmac_regs->mac_config = MSK_OX820_GMAC_MAC_CONFIG_IPC |
				MSK_OX820_GMAC_MAC_CONFIG_DM |
				MSK_OX820_GMAC_MAC_CONFIG_DO;
}
